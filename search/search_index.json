{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"DiTTo documentation! DiTTo is a Distribution Transformation Tool that aims at providing an open source framework to convert various distribution systems modeling formats. DiTTo implements a many-to-one-to-many parsing framework which makes it modular and robust. Readers and writers are then implemented to perform the translation from a given format to the core representation, or the other way around. GitHub Gitter Documentation .. toctree:: :maxdepth: 1 readme installation usage cli-examples notes contributing developer-guide/index authors","title":"Home"},{"location":"#ditto-documentation","text":"DiTTo is a Distribution Transformation Tool that aims at providing an open source framework to convert various distribution systems modeling formats. DiTTo implements a many-to-one-to-many parsing framework which makes it modular and robust. Readers and writers are then implemented to perform the translation from a given format to the core representation, or the other way around. GitHub Gitter Documentation .. toctree:: :maxdepth: 1 readme installation usage cli-examples notes contributing developer-guide/index authors","title":"DiTTo documentation!"},{"location":"authors/","text":"Credits Development Team Tarek Elgindy tarek.elgindy@nrel.gov Nicolas Gensollen Bryan Palmintier Dheepak Krishnamurthy Elaine Hale Michael Rossol Jeff Simpson","title":"Credits"},{"location":"authors/#credits","text":"","title":"Credits"},{"location":"authors/#development-team","text":"Tarek Elgindy tarek.elgindy@nrel.gov Nicolas Gensollen Bryan Palmintier Dheepak Krishnamurthy Elaine Hale Michael Rossol Jeff Simpson","title":"Development Team"},{"location":"cli-examples/","text":"DiTTo examples DiTTo basic usage is the conversion from one format to another. This readme explains how a basic conversion can be done with the command line and with a Python script. Conversion examples with more advanced features can be found in the examples sub-folders. Basic usage: Converting from one format to another Method 1: Through the command line The convert command DiTTo supports a command line interface (CLI) to quickly convert a model. The command is simply: $ ditto-cli convert Help can be obtained using: $ ditto-cli convert --help From and To The options \u2014from and \u2014to are easy to understand, they just tell ditto-cli convert what format is expected for the input, and what format is desired for the output. If we want to convert from opendss to gridlabd, we can use: $ ditto-cli convert --from opendss --to gridlabd Note that, we can use short-cut names for the format like: $ ditto-cli convert --from dss --to glm Input In addition to the formats, we need to provide some input to DiTTo. The main issue here is that inputs are very different accross formats. It is common practice in OpenDSS for example to use master files to redirect all the other dss files, while a Cyme ASCII model is composed of three files: equipment, network, and loads. To be consistent, the CLI accepts only one file whatever the format. If we have a gridlabd model entirely stored in a file called model.glm we can use: $ ditto-cli convert --from glm --input ./model.glm --to cyme For formats like Cyme where we need multiple input files, we need to write a simple JSON configuration file: !Content of config.json { \"data_folder_path\": \"/home/cyme_models/ieee_13node/\", \"network_filename\": \"net.txt\", \"equipment_filename\": \"equip.txt\", \"load_filename\": \"loads.txt\" } Which results in the following command: $ ditto-cli convert --from cyme --input ./config.json --to dss Output Finally, we need to tell ditto-cli convert where to write the output. This is done with the \u2014output option. Make sure to provide the path to the folder you want the files to be written in. For example, if we want to output in a folder named ./results we do the following: $ ditto-cli convert --from cyme --input ./config.json --to dss --output ./results/ Examples Convert the IEEE 4 node from GridlabD to OpenDSS Run the following command: $ ditto-cli convert --input ../tests/data/gridlabd/4node.glm --from glm --to dss --output ./ Convert the IEEE 13 node from OpenDSS to CYME Here, we use the configuration file: ditto/examples/ieee_13node_opendss_input.json : $ ditto-cli convert --input ../examples/ieee_13node_opendss_input.json --from opendss --to cyme --output ./ Method 2: Writing a script This is a more advanced method which provides more flexibility and enable the user to access all the functionality of DiTTo. The basic conversion scripts usually go through the following steps: Step 1: Import the required modules For basic conversion usage, we need to import a reader, a writer, and a Store object: #Import the reader #...assuming we want to read from OpenDSS from ditto.readers.opendss.read import Reader #Import the writer #...assuming we want to write to Cyme from ditto.writers.cyme.write import Writer #Import the Store #...this will always be the same from ditto.store import Store Step 2: Instanciate an empty store This step is pretty straightforward: model = Store() Step 3: Instanciate a reader This is probably the most delicate step because every reader is a bit different and expects various number of files. Refer to the documentation to know what needs to be provided. In this OpenDSS\u2014>Cyme example, we need to provide a master file and a buscoordinate file to the OpenDSS reader: dss_reader = Reader(master_file=\"./dss_models/ieee_13node/master.dss\", buscoordinate_file=\"./dss_models/ieee_13node/buscoord.dss\") Step 4: Parse This is also pretty simple. We just need to provide the emty Store object we created as an argument of the parse method. All readers implement a parse method: dss_reader.parse(model) Step 5: Instanciate the writer All writers are instanciated in the same way. We only need to provide the path to the output folder: cyme_writer = Writer(output_path=\"/results/ieee_13node/\") Step 6: Write Simply use the write method implemented by all ditto writers. We just need to provide, once again, the Store object as an argument: cyme_writer.write(model)","title":"DiTTo examples"},{"location":"cli-examples/#ditto-examples","text":"DiTTo basic usage is the conversion from one format to another. This readme explains how a basic conversion can be done with the command line and with a Python script. Conversion examples with more advanced features can be found in the examples sub-folders.","title":"DiTTo examples"},{"location":"cli-examples/#basic-usage-converting-from-one-format-to-another","text":"","title":"Basic usage: Converting from one format to another"},{"location":"cli-examples/#method-1-through-the-command-line","text":"","title":"Method 1: Through the command line"},{"location":"cli-examples/#the-convert-command","text":"DiTTo supports a command line interface (CLI) to quickly convert a model. The command is simply: $ ditto-cli convert Help can be obtained using: $ ditto-cli convert --help","title":"The convert command"},{"location":"cli-examples/#from-and-to","text":"The options \u2014from and \u2014to are easy to understand, they just tell ditto-cli convert what format is expected for the input, and what format is desired for the output. If we want to convert from opendss to gridlabd, we can use: $ ditto-cli convert --from opendss --to gridlabd Note that, we can use short-cut names for the format like: $ ditto-cli convert --from dss --to glm","title":"From and To"},{"location":"cli-examples/#input","text":"In addition to the formats, we need to provide some input to DiTTo. The main issue here is that inputs are very different accross formats. It is common practice in OpenDSS for example to use master files to redirect all the other dss files, while a Cyme ASCII model is composed of three files: equipment, network, and loads. To be consistent, the CLI accepts only one file whatever the format. If we have a gridlabd model entirely stored in a file called model.glm we can use: $ ditto-cli convert --from glm --input ./model.glm --to cyme For formats like Cyme where we need multiple input files, we need to write a simple JSON configuration file: !Content of config.json { \"data_folder_path\": \"/home/cyme_models/ieee_13node/\", \"network_filename\": \"net.txt\", \"equipment_filename\": \"equip.txt\", \"load_filename\": \"loads.txt\" } Which results in the following command: $ ditto-cli convert --from cyme --input ./config.json --to dss","title":"Input"},{"location":"cli-examples/#output","text":"Finally, we need to tell ditto-cli convert where to write the output. This is done with the \u2014output option. Make sure to provide the path to the folder you want the files to be written in. For example, if we want to output in a folder named ./results we do the following: $ ditto-cli convert --from cyme --input ./config.json --to dss --output ./results/","title":"Output"},{"location":"cli-examples/#examples","text":"","title":"Examples"},{"location":"cli-examples/#convert-the-ieee-4-node-from-gridlabd-to-opendss","text":"Run the following command: $ ditto-cli convert --input ../tests/data/gridlabd/4node.glm --from glm --to dss --output ./","title":"Convert the IEEE 4 node from GridlabD to OpenDSS"},{"location":"cli-examples/#convert-the-ieee-13-node-from-opendss-to-cyme","text":"Here, we use the configuration file: ditto/examples/ieee_13node_opendss_input.json : $ ditto-cli convert --input ../examples/ieee_13node_opendss_input.json --from opendss --to cyme --output ./","title":"Convert the IEEE 13 node from OpenDSS to CYME"},{"location":"cli-examples/#method-2-writing-a-script","text":"This is a more advanced method which provides more flexibility and enable the user to access all the functionality of DiTTo. The basic conversion scripts usually go through the following steps:","title":"Method 2: Writing a script"},{"location":"cli-examples/#step-1-import-the-required-modules","text":"For basic conversion usage, we need to import a reader, a writer, and a Store object: #Import the reader #...assuming we want to read from OpenDSS from ditto.readers.opendss.read import Reader #Import the writer #...assuming we want to write to Cyme from ditto.writers.cyme.write import Writer #Import the Store #...this will always be the same from ditto.store import Store","title":"Step 1: Import the required modules"},{"location":"cli-examples/#step-2-instanciate-an-empty-store","text":"This step is pretty straightforward: model = Store()","title":"Step 2: Instanciate an empty store"},{"location":"cli-examples/#step-3-instanciate-a-reader","text":"This is probably the most delicate step because every reader is a bit different and expects various number of files. Refer to the documentation to know what needs to be provided. In this OpenDSS\u2014>Cyme example, we need to provide a master file and a buscoordinate file to the OpenDSS reader: dss_reader = Reader(master_file=\"./dss_models/ieee_13node/master.dss\", buscoordinate_file=\"./dss_models/ieee_13node/buscoord.dss\")","title":"Step 3: Instanciate a reader"},{"location":"cli-examples/#step-4-parse","text":"This is also pretty simple. We just need to provide the emty Store object we created as an argument of the parse method. All readers implement a parse method: dss_reader.parse(model)","title":"Step 4: Parse"},{"location":"cli-examples/#step-5-instanciate-the-writer","text":"All writers are instanciated in the same way. We only need to provide the path to the output folder: cyme_writer = Writer(output_path=\"/results/ieee_13node/\")","title":"Step 5: Instanciate the writer"},{"location":"cli-examples/#step-6-write","text":"Simply use the write method implemented by all ditto writers. We just need to provide, once again, the Store object as an argument: cyme_writer.write(model)","title":"Step 6: Write"},{"location":"contributing/","text":"Contributing Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways: Types of Contributions Report Bugs Report bugs at https://github.com/NREL/ditto/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug. Fix Bugs Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it. Implement Features Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it. Write Documentation ditto could always use more documentation, whether as part of the official ditto docs, in docstrings, or even on the web in blog posts, articles, and such. Submit Feedback The best way to send feedback is to file an issue at https://github.com/NREL/ditto/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :) Get Started! Ready to contribute? Here's how to set up ditto for local development. Fork the ditto repo on GitHub. Clone your fork locally: $ git clone git@github.com:your_name_here/ditto.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development: $ conda create -n python3-env python=3 $ cd ditto/ $ pip install -e . Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox: $ flake8 ditto tests $ pytest -sv To get flake8, just pip install flake8 into your virtualenv. Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website. Pull Request Guidelines Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 2.7, and 3.5, and for 3.6. Run tests and make sure that the tests pass for all supported Python versions. Tips To run a subset of tests $ pytest -sv","title":"Contributing"},{"location":"contributing/#contributing","text":"Contributions are welcome, and they are greatly appreciated! Every little bit helps, and credit will always be given. You can contribute in many ways:","title":"Contributing"},{"location":"contributing/#types-of-contributions","text":"","title":"Types of Contributions"},{"location":"contributing/#report-bugs","text":"Report bugs at https://github.com/NREL/ditto/issues. If you are reporting a bug, please include: Your operating system name and version. Any details about your local setup that might be helpful in troubleshooting. Detailed steps to reproduce the bug.","title":"Report Bugs"},{"location":"contributing/#fix-bugs","text":"Look through the GitHub issues for bugs. Anything tagged with \"bug\" and \"help wanted\" is open to whoever wants to implement it.","title":"Fix Bugs"},{"location":"contributing/#implement-features","text":"Look through the GitHub issues for features. Anything tagged with \"enhancement\" and \"help wanted\" is open to whoever wants to implement it.","title":"Implement Features"},{"location":"contributing/#write-documentation","text":"ditto could always use more documentation, whether as part of the official ditto docs, in docstrings, or even on the web in blog posts, articles, and such.","title":"Write Documentation"},{"location":"contributing/#submit-feedback","text":"The best way to send feedback is to file an issue at https://github.com/NREL/ditto/issues. If you are proposing a feature: Explain in detail how it would work. Keep the scope as narrow as possible, to make it easier to implement. Remember that this is a volunteer-driven project, and that contributions are welcome :)","title":"Submit Feedback"},{"location":"contributing/#get-started","text":"Ready to contribute? Here's how to set up ditto for local development. Fork the ditto repo on GitHub. Clone your fork locally: $ git clone git@github.com:your_name_here/ditto.git Install your local copy into a virtualenv. Assuming you have virtualenvwrapper installed, this is how you set up your fork for local development: $ conda create -n python3-env python=3 $ cd ditto/ $ pip install -e . Create a branch for local development: $ git checkout -b name-of-your-bugfix-or-feature Now you can make your changes locally. When you're done making changes, check that your changes pass flake8 and the tests, including testing other Python versions with tox: $ flake8 ditto tests $ pytest -sv To get flake8, just pip install flake8 into your virtualenv. Commit your changes and push your branch to GitHub: $ git add . $ git commit -m \"Your detailed description of your changes.\" $ git push origin name-of-your-bugfix-or-feature Submit a pull request through the GitHub website.","title":"Get Started!"},{"location":"contributing/#pull-request-guidelines","text":"Before you submit a pull request, check that it meets these guidelines: The pull request should include tests. If the pull request adds functionality, the docs should be updated. Put your new functionality into a function with a docstring, and add the feature to the list in README.rst. The pull request should work for Python 2.7, and 3.5, and for 3.6. Run tests and make sure that the tests pass for all supported Python versions.","title":"Pull Request Guidelines"},{"location":"contributing/#tips","text":"To run a subset of tests $ pytest -sv","title":"Tips"},{"location":"history/","text":"","title":"History"},{"location":"installation/","text":"Installation Stable release To install the latest version of ditto from master for development, run this command in your terminal after changing your directory to the folder where you'd like to set up the development: $ pip install git+https://github.com/NREL/ditto.git@master#egg=ditto[all] From sources The sources for ditto can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/NREL/ditto Or download the tarball : $ curl -OL https://github.com/NREL/ditto/tarball/master Once you have a copy of the source, you can install it with: $ pip install -e .[all] See the developer guide for instructions on how to add features to ditto. Install specific packages alone If you want specific packages alone, you will be able to do the following: $ pip install git+https://github.com/NREL/ditto.git@master#egg=ditto $ ditto list --readers $ ditto list --writers $ pip install git+https://github.com/NREL/ditto.git@master#egg=ditto[opendss,gridlabd]","title":"Installation"},{"location":"installation/#installation","text":"Stable release To install the latest version of ditto from master for development, run this command in your terminal after changing your directory to the folder where you'd like to set up the development: $ pip install git+https://github.com/NREL/ditto.git@master#egg=ditto[all] From sources The sources for ditto can be downloaded from the Github repo . You can either clone the public repository: $ git clone git://github.com/NREL/ditto Or download the tarball : $ curl -OL https://github.com/NREL/ditto/tarball/master Once you have a copy of the source, you can install it with: $ pip install -e .[all] See the developer guide for instructions on how to add features to ditto. Install specific packages alone If you want specific packages alone, you will be able to do the following: $ pip install git+https://github.com/NREL/ditto.git@master#egg=ditto $ ditto list --readers $ ditto list --writers $ pip install git+https://github.com/NREL/ditto.git@master#egg=ditto[opendss,gridlabd]","title":"Installation"},{"location":"metrics/","text":"Metrics documentation DiTTo has the capability to extract metrics from a system once parsed in the core representation. This enables the user to compute metrics when doing a conversion from one format to another. The advantage compared to computing metrics on a given format is that no conversion is needed prior to the caculation. List of available metrics Here is the list of implemented metrics with their description. The list is organized in different sections to ease the search. Realistic electrical design and equipment parameters (MV) Metric name Type Unit Metric description Comments mv_len_mi Float miles The total length of medium voltage lines. Needs the nominal voltages mv_3ph_len_mi Float miles The total length of medium voltage, 3 phase lines. Needs the nominal voltages mv_oh_3ph_len_mi Float miles The total length of medium voltage, overhead, 3 phase lines. Needs the nominal voltages and line_type. mv_2ph_len_mi Float miles The total length of medium voltage, 2 phase lines. Needs the nominal voltages mv_oh_2ph_len_mi Float miles The total length of medium voltage, overhead, 2 phase lines. Needs the nominal voltages and line_type. mv_1ph_len_mi Float miles The total length of medium voltage, 1 phase lines. Needs the nominal voltages mv_oh_1ph_len_mi Float miles The total length of medium voltage, overhead, 1 phase lines. Needs the nominal voltages and line_type. perct_mv_oh_len Float - Percentage of MV lines that are overhead lines. Needs the nominal voltages and line_type. ratio_mv_len_to_num_cust Float miles mv_length_miles devided by the number of customers. Needs nominal voltages and load information. max_sub_node_distance_mi Float miles Maximum distance between the substation and any node of the network. nominal_medium_voltage_class Float Volts Nominal voltage of medium voltage. Realistic electrical design and equipment parameters (LV) Metric name Type Unit Metric description Comments lv_len_mi Float miles The total length of low voltage lines. Needs the nominal voltages lv_3ph_len_mi Float miles The total length of low voltage, 3 phase lines. Needs the nominal voltages lv_oh_3ph_len_mi Float miles The total length of low voltage, overhead, 3 phase lines. Needs the nominal voltages and line_type. lv_1ph_len_mi Float miles The total length of low voltage, 1 phase lines. Needs the nominal voltages lv_oh_1ph_len_mi Float miles The total length of low voltage, overhead, 1 phase lines. Needs the nominal voltages and line_type. max_lv_line: Float miles The maximum length between a distribution transformer and a low voltage customer. Needs the nominal voltages lv_2ph_len_mi Float miles The total length of low voltage, 2 phase lines. Needs the nominal voltages lv_oh_2ph_len_mi Float miles The total length of low voltage, overhead, 2 phase lines. Needs the nominal voltages and line_type. perct_lv_oh_len Float - Percentage of LV lines that are overhead lines. Needs the nominal voltages and line_type. ratio_lv_len_to_num_cust Float miles lv_length_miles devided by the number of customers. Needs nominal voltages and load information. Voltage control schemes Metric name Type Unit Metric description Comments num_regulators Integer - The number of regulator objects. num_capacitors Integer - The number of capacitor banks. num_boosters Integer - The number of boosters. Boosters are not currently implemented in DiTTo. avg_regulator_sub_distance_mi Float miles Mean distance between the substation and regulator objects. If no regulator, this metric is Nan. avg_capacitor_sub_distance_mi Float miles Mean distance between the substation and capacitor bank objects. If no capacitor, this metric is Nan. Basic protection Metric name Type Unit Metric description Comments num_fuses Integer - Number of Fuses. num_reclosers Integer - Number of Reclosers. num_sectionalizers Integer - Number of Sectionalizers. num_sectionalizers_per_recloser Float - No_of_Sectionalizers divided by No_of_Reclosers . If no recloser, this metric is Nan avg_recloser_sub_distance_mi Float miles Mean distance between the substation and recloser objects. If no recloser, this metric is Nan num_breakers Integer - Number of Breakers. Reconfiguration Options Metric name Type Unit Metric description Comments num_switches Integer - Number of switches. num_interruptors Integer - Number of interruptors. num_links_adjacent_feeders Integer - Number of links between the current feeder and other feeders. This metrics only works when computing metrics per feeder on a system with multiple feeders. num_loops Integer - Number of loops within the feeder. Transformers Metric name Type Unit Metric description Comments num_distribution_transformers Integer - Number of distribution transformers. num_overloaded_transformers Integer - Number of distribution transformers where its secondary KVA rating is smaller than the sum of downstream load KVA. sum_distribution_transformer_mva Float MVA Sum of distribution transformer total capacity (sum of ratings accross the windings) num_1ph_transformers Integer - Number of one phase transformers. num_3ph_transformers Integer - Number of three phase transformers. ratio_1ph_to_3ph_transformers Float - nb_1ph_Xfrm divided by nb_3ph_Xfrm if there is no three phase transformer, this metric is Nan. Substations Metric name Type Unit Metric description Comments substation_name String - The name of the substation. sub_capacity_mva Float MVA The capacity of the substation. Load specification Metric name Type Unit Metric description Comments sum_load_kw Float Watts Total active power demand. sum_load_pha_kw Float Watts Total active power demand on phase A. sum_load_phb_kw Float Watts Total active power demand on phase B. sum_load_phc_kw Float Watts Total active power demand on phase C. sum_load_kvar Float Vars Total reactive power demand. perct_lv_pha_load_kw Float - Percentage of low voltage active power demand on phase A. perct_lv_phb_load_kw Float - Percentage of low voltage active power demand on phase B. perct_lv_phc_load_kw Float - Percentage of low voltage active power demand on phase C. num_lv_1ph_loads Integer - Number of low voltage, 1 phase loads num_lv_3ph_loads Integer - Number of low voltage, 3 phase loads num_mv_3ph_loads Integer - Number of medium voltage, 3 phase loads avg_num_load_per_transformer Float - Average number of loads per distribution transformer. avg_load_pf Float - Average power factor for loads. avg_load_imbalance_by_phase Float Watts TODO num_customers Integer - Number of customers. Need customer information. customer_density Float per square miles No_of_Customers divided by the convex Hull surface of the feeder. load_density_kw Float per square miles Total_Demand_kW divided by the convex Hull surface of the feeder. load_density_kvar Float per square miles Total_Reactive_Power_kVar divided by the convex Hull surface of the feeder. Graph Topology Metric name Type Unit Metric description Comments avg_degree Float - Mean degree. Char_path_Length Float - Average path length. diameter Float - Diameter of the graph. How to compute the metrics Easy situation: compute metrics on a single feeder Method 1: Command Line Interface Not implemented yet. Method 2: Using a Python script Step 1: Read the model into DiTTo We assume that we have a model in OpenDSS representing a single feeder, and that we want to compute all the available metrics on it. The first step is to read in the model (more information on reading capabilities in cli-examples.md ) from ditto.model.store import Store from ditto.readers.opendss.read import Reader model = Store() #Create a Store object #Initialize the reader with the master and coordinate files of our system dss_reader = Reader(master_file='./OpenDSS/master.dss', buscoordinates_file='./OpenDSS/buscoords.dss') #Parse... dss_reader.parse(model) Step 2: Modify the model (optional) This step is optional but most of the time needed. In our example, since we are reading from OpenDSS, we do not have information on the nominal voltages for Nodes and Lines . Since a lot of metrics are divided according to low voltage (LV) and medium voltage (MV), we need to add this information. In this situation, we have the nominal voltage of the source as well as the nominal voltage of the transformers (primary and secondary). We can use the following approach that will go from the source down to the customers and set the nominal voltages of the equipments: from ditto.modify.system_structure import system_structure_modifier #Create a system_structure_modifier object #We can specify the name of the source and its voltage #Otherwise, the source and its voltage will be search in the model modifier = system_structure_modifier(model) #Set the nominal voltages of all nodes in the system modifier.set_nominal_voltages_recur() #Use the nodes voltages to set the nominal voltages of the lines modifier.set_nominal_voltages_recur_line() This example only shows one of the modification possibilities. More information on modifications and post-processing can be found in modifications.md Step 3: Compute the metrics This step of the process creates a NetworkAnalyzer object with the modified model and compute the metrics on it: from ditto.metrics.network_analysis import NetworkAnalyzer #Instanciate the NetworkAnalyzer object #WARNING: In case the model was modified, we need to use modifier.model #If we did not do any changes, then simply pass model #Again, the name of the source can be provided to avoid the search network_analyst = NetworkAnalyzer(modifier.model) #Compute all the metrics network_analyst.compute_all_metrics() In this example, we have a single feeder so we call the compute_all_metrics() method. It is also possible to compute metrics per feeder when we have a system with multiple feeders using the compute_all_metrics_per_feeder() method. The process might be a bit more complicated since the network has to be properly partitioned. More information for this process is available in the section \"Advanced: Compute metrics for multiple feeders\". Step 4: View/export the results The final step of the process is obviously to have a look at the metrics. There are mainly two ways to do so. The first method is simply to look at the results attribute of the NetworkAnalyzer : print(network_analyst.results) This prints a dictionary where the keys are the feeder names (in our case we have only one key since we have only one feeder), and the values are dictionaries holding the metrics: {'name_of_feeder1': {'name_of_metric1': value1, 'name_of_metric2': value2, ... } 'name_of_feeder2': {'name_of_metric1': value1, 'name_of_metric2': value2, ... } ... } Getting a the value of a specific metric for a given feeder: print(network_analyst.results['name_of_feeder1']['name_of_metric2']) The second method is to export the metrics first and look at the export. The metrics can be exported to Excel using: #Provide the path to the file network_analyst.export('./output/metrics.xlsx') Note that this will not export distribution metrics. To export everything in network_analyst.results use the JSON export method: network_analyst.export_json('./output/metrics.json') Advanced: compute metrics for multiple feeders Method 1: Command Line Interface Not implemented yet. Method 2: Using a Python script It is also possible to extract metrics when we have a system composed of multiple feeders. In this situation, we might want to: compute the metrics on the whole system compute the metrics for all feeders The first point is straightforward, just proceed as for the single feeder case. Step 1 and 2: Read and modify as before For computing metrics per feeder, we first read the model into DiTTo and apply, if needed, modifications to it (exactly as for the single feeder case): from ditto.model.store import Store from ditto.readers.opendss.read import Reader from ditto.modify.system_structure import system_structure_modifier model = Store() #Create a Store object #Initialize the reader with the master and coordinate files of our system dss_reader = Reader(master_file='./OpenDSS/master.dss', buscoordinates_file='./OpenDSS/buscoords.dss') #Parse... dss_reader.parse(model) #Create a system_structure_modifier object #We can specify the name of the source and its voltage #Otherwise, the source and its voltage will be search in the model modifier = system_structure_modifier(model) #Set the nominal voltages of all nodes in the system modifier.set_nominal_voltages_recur() #Use the nodes voltages to set the nominal voltages of the lines modifier.set_nominal_voltages_recur_line() Step 3: Create a network analyzer We then create a NetworkAnalyzer object as for the single feeder case: from ditto.metrics.network_analysis import NetworkAnalyzer #Instanciate the NetworkAnalyzer object network_analyst = NetworkAnalyzer(modifier.model) Step 4: Provide information on the feeder compositions Now, we need to provide feeder information to the NetworkAnalyzer using the add_feeder_information() method wich takes the following inputs: feeder_names List of names for the feeders feeder_nodes List of lists which contains all nodes in the feeders. Thats is, feeder_nodes[2] is the full list of nodes belonging to feeder_names[2] substations List of the substation names. feeder_types This could be a list of strings to tag each feeder with a type ( industrial rural or a single string to tag all feeders with the same type. Example: #Fake feeder information feeder_names = ['feeder_1', 'feeder_2', 'feeder_3'] feeder_nodes = [ ['A','B','C'], ['D','E','F','G','H'], ['I','J','K','L']] substations = ['sub_1', 'sub2', 'sub3'] feeder_types = ['industrial', 'rural', 'urban'] #Add the feeder information to the network analyzer network_analyst.add_feeder_information(feeder_names, feeder_nodes, substations, feeder_types) This means that you currently have to generate the 4 arguments yourself. Algorithms to automatically split a given network into multiple feeders are currently tested yet but none has been released yet. Step 5: Split the network and compute the metrics Once this is done, we simply have to call the following methods: #Split the network representation into multiple subnetworks network_analyst.split_network_into_feeders() #Loop over the DiTTo objects and set the feeder_name attribute network_analyst.tag_objects() #Set the names network_analyst.model.set_names() #Compute the metrics per feeders network_analyst.compute_all_metrics_per_feeder() Step 6: Export the metrics This works exactly as for the single feeder case.","title":"Metrics documentation"},{"location":"metrics/#metrics-documentation","text":"DiTTo has the capability to extract metrics from a system once parsed in the core representation. This enables the user to compute metrics when doing a conversion from one format to another. The advantage compared to computing metrics on a given format is that no conversion is needed prior to the caculation.","title":"Metrics documentation"},{"location":"metrics/#list-of-available-metrics","text":"Here is the list of implemented metrics with their description. The list is organized in different sections to ease the search.","title":"List of available metrics"},{"location":"metrics/#realistic-electrical-design-and-equipment-parameters-mv","text":"Metric name Type Unit Metric description Comments mv_len_mi Float miles The total length of medium voltage lines. Needs the nominal voltages mv_3ph_len_mi Float miles The total length of medium voltage, 3 phase lines. Needs the nominal voltages mv_oh_3ph_len_mi Float miles The total length of medium voltage, overhead, 3 phase lines. Needs the nominal voltages and line_type. mv_2ph_len_mi Float miles The total length of medium voltage, 2 phase lines. Needs the nominal voltages mv_oh_2ph_len_mi Float miles The total length of medium voltage, overhead, 2 phase lines. Needs the nominal voltages and line_type. mv_1ph_len_mi Float miles The total length of medium voltage, 1 phase lines. Needs the nominal voltages mv_oh_1ph_len_mi Float miles The total length of medium voltage, overhead, 1 phase lines. Needs the nominal voltages and line_type. perct_mv_oh_len Float - Percentage of MV lines that are overhead lines. Needs the nominal voltages and line_type. ratio_mv_len_to_num_cust Float miles mv_length_miles devided by the number of customers. Needs nominal voltages and load information. max_sub_node_distance_mi Float miles Maximum distance between the substation and any node of the network. nominal_medium_voltage_class Float Volts Nominal voltage of medium voltage.","title":"Realistic electrical design and equipment parameters (MV)"},{"location":"metrics/#realistic-electrical-design-and-equipment-parameters-lv","text":"Metric name Type Unit Metric description Comments lv_len_mi Float miles The total length of low voltage lines. Needs the nominal voltages lv_3ph_len_mi Float miles The total length of low voltage, 3 phase lines. Needs the nominal voltages lv_oh_3ph_len_mi Float miles The total length of low voltage, overhead, 3 phase lines. Needs the nominal voltages and line_type. lv_1ph_len_mi Float miles The total length of low voltage, 1 phase lines. Needs the nominal voltages lv_oh_1ph_len_mi Float miles The total length of low voltage, overhead, 1 phase lines. Needs the nominal voltages and line_type. max_lv_line: Float miles The maximum length between a distribution transformer and a low voltage customer. Needs the nominal voltages lv_2ph_len_mi Float miles The total length of low voltage, 2 phase lines. Needs the nominal voltages lv_oh_2ph_len_mi Float miles The total length of low voltage, overhead, 2 phase lines. Needs the nominal voltages and line_type. perct_lv_oh_len Float - Percentage of LV lines that are overhead lines. Needs the nominal voltages and line_type. ratio_lv_len_to_num_cust Float miles lv_length_miles devided by the number of customers. Needs nominal voltages and load information.","title":"Realistic electrical design and equipment parameters (LV)"},{"location":"metrics/#voltage-control-schemes","text":"Metric name Type Unit Metric description Comments num_regulators Integer - The number of regulator objects. num_capacitors Integer - The number of capacitor banks. num_boosters Integer - The number of boosters. Boosters are not currently implemented in DiTTo. avg_regulator_sub_distance_mi Float miles Mean distance between the substation and regulator objects. If no regulator, this metric is Nan. avg_capacitor_sub_distance_mi Float miles Mean distance between the substation and capacitor bank objects. If no capacitor, this metric is Nan.","title":"Voltage control schemes"},{"location":"metrics/#basic-protection","text":"Metric name Type Unit Metric description Comments num_fuses Integer - Number of Fuses. num_reclosers Integer - Number of Reclosers. num_sectionalizers Integer - Number of Sectionalizers. num_sectionalizers_per_recloser Float - No_of_Sectionalizers divided by No_of_Reclosers . If no recloser, this metric is Nan avg_recloser_sub_distance_mi Float miles Mean distance between the substation and recloser objects. If no recloser, this metric is Nan num_breakers Integer - Number of Breakers.","title":"Basic protection"},{"location":"metrics/#reconfiguration-options","text":"Metric name Type Unit Metric description Comments num_switches Integer - Number of switches. num_interruptors Integer - Number of interruptors. num_links_adjacent_feeders Integer - Number of links between the current feeder and other feeders. This metrics only works when computing metrics per feeder on a system with multiple feeders. num_loops Integer - Number of loops within the feeder.","title":"Reconfiguration Options"},{"location":"metrics/#transformers","text":"Metric name Type Unit Metric description Comments num_distribution_transformers Integer - Number of distribution transformers. num_overloaded_transformers Integer - Number of distribution transformers where its secondary KVA rating is smaller than the sum of downstream load KVA. sum_distribution_transformer_mva Float MVA Sum of distribution transformer total capacity (sum of ratings accross the windings) num_1ph_transformers Integer - Number of one phase transformers. num_3ph_transformers Integer - Number of three phase transformers. ratio_1ph_to_3ph_transformers Float - nb_1ph_Xfrm divided by nb_3ph_Xfrm if there is no three phase transformer, this metric is Nan.","title":"Transformers"},{"location":"metrics/#substations","text":"Metric name Type Unit Metric description Comments substation_name String - The name of the substation. sub_capacity_mva Float MVA The capacity of the substation.","title":"Substations"},{"location":"metrics/#load-specification","text":"Metric name Type Unit Metric description Comments sum_load_kw Float Watts Total active power demand. sum_load_pha_kw Float Watts Total active power demand on phase A. sum_load_phb_kw Float Watts Total active power demand on phase B. sum_load_phc_kw Float Watts Total active power demand on phase C. sum_load_kvar Float Vars Total reactive power demand. perct_lv_pha_load_kw Float - Percentage of low voltage active power demand on phase A. perct_lv_phb_load_kw Float - Percentage of low voltage active power demand on phase B. perct_lv_phc_load_kw Float - Percentage of low voltage active power demand on phase C. num_lv_1ph_loads Integer - Number of low voltage, 1 phase loads num_lv_3ph_loads Integer - Number of low voltage, 3 phase loads num_mv_3ph_loads Integer - Number of medium voltage, 3 phase loads avg_num_load_per_transformer Float - Average number of loads per distribution transformer. avg_load_pf Float - Average power factor for loads. avg_load_imbalance_by_phase Float Watts TODO num_customers Integer - Number of customers. Need customer information. customer_density Float per square miles No_of_Customers divided by the convex Hull surface of the feeder. load_density_kw Float per square miles Total_Demand_kW divided by the convex Hull surface of the feeder. load_density_kvar Float per square miles Total_Reactive_Power_kVar divided by the convex Hull surface of the feeder.","title":"Load specification"},{"location":"metrics/#graph-topology","text":"Metric name Type Unit Metric description Comments avg_degree Float - Mean degree. Char_path_Length Float - Average path length. diameter Float - Diameter of the graph.","title":"Graph Topology"},{"location":"metrics/#how-to-compute-the-metrics","text":"","title":"How to compute the metrics"},{"location":"metrics/#easy-situation-compute-metrics-on-a-single-feeder","text":"","title":"Easy situation: compute metrics on a single feeder"},{"location":"metrics/#method-1-command-line-interface","text":"Not implemented yet.","title":"Method 1: Command Line Interface"},{"location":"metrics/#method-2-using-a-python-script","text":"","title":"Method 2: Using a Python script"},{"location":"metrics/#step-1-read-the-model-into-ditto","text":"We assume that we have a model in OpenDSS representing a single feeder, and that we want to compute all the available metrics on it. The first step is to read in the model (more information on reading capabilities in cli-examples.md ) from ditto.model.store import Store from ditto.readers.opendss.read import Reader model = Store() #Create a Store object #Initialize the reader with the master and coordinate files of our system dss_reader = Reader(master_file='./OpenDSS/master.dss', buscoordinates_file='./OpenDSS/buscoords.dss') #Parse... dss_reader.parse(model)","title":"Step 1: Read the model into DiTTo"},{"location":"metrics/#step-2-modify-the-model-optional","text":"This step is optional but most of the time needed. In our example, since we are reading from OpenDSS, we do not have information on the nominal voltages for Nodes and Lines . Since a lot of metrics are divided according to low voltage (LV) and medium voltage (MV), we need to add this information. In this situation, we have the nominal voltage of the source as well as the nominal voltage of the transformers (primary and secondary). We can use the following approach that will go from the source down to the customers and set the nominal voltages of the equipments: from ditto.modify.system_structure import system_structure_modifier #Create a system_structure_modifier object #We can specify the name of the source and its voltage #Otherwise, the source and its voltage will be search in the model modifier = system_structure_modifier(model) #Set the nominal voltages of all nodes in the system modifier.set_nominal_voltages_recur() #Use the nodes voltages to set the nominal voltages of the lines modifier.set_nominal_voltages_recur_line() This example only shows one of the modification possibilities. More information on modifications and post-processing can be found in modifications.md","title":"Step 2: Modify the model (optional)"},{"location":"metrics/#step-3-compute-the-metrics","text":"This step of the process creates a NetworkAnalyzer object with the modified model and compute the metrics on it: from ditto.metrics.network_analysis import NetworkAnalyzer #Instanciate the NetworkAnalyzer object #WARNING: In case the model was modified, we need to use modifier.model #If we did not do any changes, then simply pass model #Again, the name of the source can be provided to avoid the search network_analyst = NetworkAnalyzer(modifier.model) #Compute all the metrics network_analyst.compute_all_metrics() In this example, we have a single feeder so we call the compute_all_metrics() method. It is also possible to compute metrics per feeder when we have a system with multiple feeders using the compute_all_metrics_per_feeder() method. The process might be a bit more complicated since the network has to be properly partitioned. More information for this process is available in the section \"Advanced: Compute metrics for multiple feeders\".","title":"Step 3: Compute the metrics"},{"location":"metrics/#step-4-viewexport-the-results","text":"The final step of the process is obviously to have a look at the metrics. There are mainly two ways to do so. The first method is simply to look at the results attribute of the NetworkAnalyzer : print(network_analyst.results) This prints a dictionary where the keys are the feeder names (in our case we have only one key since we have only one feeder), and the values are dictionaries holding the metrics: {'name_of_feeder1': {'name_of_metric1': value1, 'name_of_metric2': value2, ... } 'name_of_feeder2': {'name_of_metric1': value1, 'name_of_metric2': value2, ... } ... } Getting a the value of a specific metric for a given feeder: print(network_analyst.results['name_of_feeder1']['name_of_metric2']) The second method is to export the metrics first and look at the export. The metrics can be exported to Excel using: #Provide the path to the file network_analyst.export('./output/metrics.xlsx') Note that this will not export distribution metrics. To export everything in network_analyst.results use the JSON export method: network_analyst.export_json('./output/metrics.json')","title":"Step 4: View/export the results"},{"location":"metrics/#advanced-compute-metrics-for-multiple-feeders","text":"","title":"Advanced: compute metrics for multiple feeders"},{"location":"metrics/#method-1-command-line-interface_1","text":"Not implemented yet.","title":"Method 1: Command Line Interface"},{"location":"metrics/#method-2-using-a-python-script_1","text":"It is also possible to extract metrics when we have a system composed of multiple feeders. In this situation, we might want to: compute the metrics on the whole system compute the metrics for all feeders The first point is straightforward, just proceed as for the single feeder case.","title":"Method 2: Using a Python script"},{"location":"metrics/#step-1-and-2-read-and-modify-as-before","text":"For computing metrics per feeder, we first read the model into DiTTo and apply, if needed, modifications to it (exactly as for the single feeder case): from ditto.model.store import Store from ditto.readers.opendss.read import Reader from ditto.modify.system_structure import system_structure_modifier model = Store() #Create a Store object #Initialize the reader with the master and coordinate files of our system dss_reader = Reader(master_file='./OpenDSS/master.dss', buscoordinates_file='./OpenDSS/buscoords.dss') #Parse... dss_reader.parse(model) #Create a system_structure_modifier object #We can specify the name of the source and its voltage #Otherwise, the source and its voltage will be search in the model modifier = system_structure_modifier(model) #Set the nominal voltages of all nodes in the system modifier.set_nominal_voltages_recur() #Use the nodes voltages to set the nominal voltages of the lines modifier.set_nominal_voltages_recur_line()","title":"Step 1 and 2: Read and modify as before"},{"location":"metrics/#step-3-create-a-network-analyzer","text":"We then create a NetworkAnalyzer object as for the single feeder case: from ditto.metrics.network_analysis import NetworkAnalyzer #Instanciate the NetworkAnalyzer object network_analyst = NetworkAnalyzer(modifier.model)","title":"Step 3: Create a network analyzer"},{"location":"metrics/#step-4-provide-information-on-the-feeder-compositions","text":"Now, we need to provide feeder information to the NetworkAnalyzer using the add_feeder_information() method wich takes the following inputs: feeder_names List of names for the feeders feeder_nodes List of lists which contains all nodes in the feeders. Thats is, feeder_nodes[2] is the full list of nodes belonging to feeder_names[2] substations List of the substation names. feeder_types This could be a list of strings to tag each feeder with a type ( industrial rural or a single string to tag all feeders with the same type. Example: #Fake feeder information feeder_names = ['feeder_1', 'feeder_2', 'feeder_3'] feeder_nodes = [ ['A','B','C'], ['D','E','F','G','H'], ['I','J','K','L']] substations = ['sub_1', 'sub2', 'sub3'] feeder_types = ['industrial', 'rural', 'urban'] #Add the feeder information to the network analyzer network_analyst.add_feeder_information(feeder_names, feeder_nodes, substations, feeder_types) This means that you currently have to generate the 4 arguments yourself. Algorithms to automatically split a given network into multiple feeders are currently tested yet but none has been released yet.","title":"Step 4: Provide information on the feeder compositions"},{"location":"metrics/#step-5-split-the-network-and-compute-the-metrics","text":"Once this is done, we simply have to call the following methods: #Split the network representation into multiple subnetworks network_analyst.split_network_into_feeders() #Loop over the DiTTo objects and set the feeder_name attribute network_analyst.tag_objects() #Set the names network_analyst.model.set_names() #Compute the metrics per feeders network_analyst.compute_all_metrics_per_feeder()","title":"Step 5: Split the network and compute the metrics"},{"location":"metrics/#step-6-export-the-metrics","text":"This works exactly as for the single feeder case.","title":"Step 6: Export the metrics"},{"location":"modifications/","text":"Modifications documentation DiTTo has the capability of modifying models once parsed into the core representation. Overview Explain here the typical workflow to apply modifications. List of examples Here is a list of usual modifications. Set the nominal voltages TODO TODO TODO...","title":"Modifications documentation"},{"location":"modifications/#modifications-documentation","text":"DiTTo has the capability of modifying models once parsed into the core representation.","title":"Modifications documentation"},{"location":"modifications/#overview","text":"Explain here the typical workflow to apply modifications.","title":"Overview"},{"location":"modifications/#list-of-examples","text":"Here is a list of usual modifications.","title":"List of examples"},{"location":"modifications/#set-the-nominal-voltages","text":"TODO","title":"Set the nominal voltages"},{"location":"modifications/#todo","text":"","title":"TODO"},{"location":"modifications/#todo_1","text":"","title":"TODO..."},{"location":"notes/","text":"Notes Tips to use DiTTo Developing DiTTo","title":"Notes"},{"location":"notes/#notes","text":"","title":"Notes"},{"location":"notes/#tips-to-use-ditto","text":"","title":"Tips to use DiTTo"},{"location":"notes/#developing-ditto","text":"","title":"Developing DiTTo"},{"location":"plugin/","text":"============ Plugin ============ Reader This section describes the API for the reader plugin. A reader plugin should parse an input file and set attributes on the instance of the Model object. The Model supports adding objects such as ConnectivityNodes, ACLineSegment, etc. These objects are stored in a dictionary","title":"Plugin"},{"location":"plugin/#reader","text":"This section describes the API for the reader plugin. A reader plugin should parse an input file and set attributes on the instance of the Model object. The Model supports adding objects such as ConnectivityNodes, ACLineSegment, etc. These objects are stored in a dictionary","title":"Reader"},{"location":"power_flow_minimum_requirements/","text":"Power Flow Minimum Requirements This document provides a list of the smallest possible set of DiTTo attributes required during a conversion if a snapshot power flow needs to be run on the output. Node Attribute Comments name phases Line Attribute Comments name length Needed since some parameters are specified in per-unit length. line_type Equations are different for overhead and underground lines. from_element Connectivity is required. to_element Connectivity is required. wires Wires are needed even if only the phase will be defined for each wire (see Wire section). impedance_matrix Note : If switching equipments, fuses and so on need to be also modeled, then use the flag attributes (ex: is_switch ). Wire Attribute Comments phase ampacity Not sure about this one, might not be absolutely required for power flow Note : This is assuming the impedance matrix of the line has been provided. Otherwise, wire parameters like resistance , gmr , and so on need to be defined here. PowerTransformer Attribute Comments name from_element Connectivity is required. to_element Connectivity is required. reactances windings Need to provide some Winding information (see Winding section). loadloss Less sure about this one. Winding Attribute Comments connection_type nominal_voltage phase_windings Need to provide some PhaseWinding information (see PhaseWinding section). rated_power This is supposed to move to PowerTransformer one day as this is confusing... PhaseWinding Attribute Comments phase Regulator Attribute Comments name bandcenter bandwidth from_element Connectivity is required. to_element Connectivity is required. windings Need to provide some Winding information (see Winding section). setpoint This is a recent addition from Tarek, not sure how this is used. Capacitor Attribute Comments name nominal_voltage connection_type mode low high connecting_element Connectivity is required. phase_capacitors Need to provide some PhaseCapacitor information (see PhaseCapacitor section). measuring_element PhaseCapacitor Attribute Comments phase var Load Attribute Comments name nominal_voltage connection_type phase_loads Need to provide some PhaseLoad information (see PhaseLoad section). connecting_element Connectivity is required. PhaseLoad Attribute Comments phase p q model PowerSource Attribute Comments name nominal_voltage phases is_sourcebus rated_power connecting_element Connectivity is required. Note: You need to define a power source at the feeder head.","title":"Power Flow Minimum Requirements"},{"location":"power_flow_minimum_requirements/#power-flow-minimum-requirements","text":"This document provides a list of the smallest possible set of DiTTo attributes required during a conversion if a snapshot power flow needs to be run on the output.","title":"Power Flow Minimum Requirements"},{"location":"power_flow_minimum_requirements/#node","text":"Attribute Comments name phases","title":"Node"},{"location":"power_flow_minimum_requirements/#line","text":"Attribute Comments name length Needed since some parameters are specified in per-unit length. line_type Equations are different for overhead and underground lines. from_element Connectivity is required. to_element Connectivity is required. wires Wires are needed even if only the phase will be defined for each wire (see Wire section). impedance_matrix Note : If switching equipments, fuses and so on need to be also modeled, then use the flag attributes (ex: is_switch ).","title":"Line"},{"location":"power_flow_minimum_requirements/#wire","text":"Attribute Comments phase ampacity Not sure about this one, might not be absolutely required for power flow Note : This is assuming the impedance matrix of the line has been provided. Otherwise, wire parameters like resistance , gmr , and so on need to be defined here.","title":"Wire"},{"location":"power_flow_minimum_requirements/#powertransformer","text":"Attribute Comments name from_element Connectivity is required. to_element Connectivity is required. reactances windings Need to provide some Winding information (see Winding section). loadloss Less sure about this one.","title":"PowerTransformer"},{"location":"power_flow_minimum_requirements/#winding","text":"Attribute Comments connection_type nominal_voltage phase_windings Need to provide some PhaseWinding information (see PhaseWinding section). rated_power This is supposed to move to PowerTransformer one day as this is confusing...","title":"Winding"},{"location":"power_flow_minimum_requirements/#phasewinding","text":"Attribute Comments phase","title":"PhaseWinding"},{"location":"power_flow_minimum_requirements/#regulator","text":"Attribute Comments name bandcenter bandwidth from_element Connectivity is required. to_element Connectivity is required. windings Need to provide some Winding information (see Winding section). setpoint This is a recent addition from Tarek, not sure how this is used.","title":"Regulator"},{"location":"power_flow_minimum_requirements/#capacitor","text":"Attribute Comments name nominal_voltage connection_type mode low high connecting_element Connectivity is required. phase_capacitors Need to provide some PhaseCapacitor information (see PhaseCapacitor section). measuring_element","title":"Capacitor"},{"location":"power_flow_minimum_requirements/#phasecapacitor","text":"Attribute Comments phase var","title":"PhaseCapacitor"},{"location":"power_flow_minimum_requirements/#load","text":"Attribute Comments name nominal_voltage connection_type phase_loads Need to provide some PhaseLoad information (see PhaseLoad section). connecting_element Connectivity is required.","title":"Load"},{"location":"power_flow_minimum_requirements/#phaseload","text":"Attribute Comments phase p q model","title":"PhaseLoad"},{"location":"power_flow_minimum_requirements/#powersource","text":"Attribute Comments name nominal_voltage phases is_sourcebus rated_power connecting_element Connectivity is required. Note: You need to define a power source at the feeder head.","title":"PowerSource"},{"location":"usage/","text":"Usage The most common usage is when one has a system in a given format, say OpenDSS, and wants to convert it to another format, say CYME. The convertion process will always be structured in the following way: Instanciate a store object which will store all the objects and attributes of your model from ditto.store import Store m=Store() Instanciate a reader object with the required arguments. These arguments may vary depending on the format. For example, the OpenDSS reader expects a path for the master.dss file as well as a path for the buscoord.dss file. from ditto.readers.opendss.read import reader opendss_reader=reader(master_file='/Users/johny_cash/IEEE_13_node/master.dss, buscoordinates_file='/Users/johny_cash/IEEE_13_node/buscoords.dss') Call the parse method of the reader with the store object as argument. opendss_reader.parse(m) Instanciate a writer object with the required arguments (output folder path\u2026). from ditto.writers.cyme.write import writer cyme_writer=writer(output_path='./', log_path='./') Call the write method of the writer with the store object as argument. cyme_writer.write(m) How is the code structured? Here is a simplified view of the code structure (only the key components are displayed): DiTTo \u2502 README.md \u2502 docs | tests \u2502 \u2514\u2500\u2500\u2500ditto \u2502 store.py \u2502 \u2514\u2500\u2500\u2500core | \u2502 base.py | \u2502 _factory.py | \u2502 exceptions.py | \u2514\u2500\u2500\u2500readers | \u2514\u2500\u2500\u2500cyme | | | read.py | \u2514\u2500\u2500\u2500opendss | | read.py | \u2514\u2500\u2500\u2500writers \u2514\u2500\u2500\u2500cyme | | write.py \u2514\u2500\u2500\u2500opendss | write.py Most of the code is located in the ditto directory. The core structure responsible for storing the objects is implemented in the core folder. Readers are implemented in readers and writers in writers. These two folders then contain the different format in different subfolders. Example 1: The OpenDSS reader is located in: DiTTo/ditto/readers/opendss/read.py And can be imported with: from ditto.readers.opendss.read import Reader Example 2: The CYME writer is located in: DiTTo/ditto/writers/cyme/write.py And can be imported with: from ditto.writers.cyme.write import Writer","title":"Usage"},{"location":"usage/#usage","text":"The most common usage is when one has a system in a given format, say OpenDSS, and wants to convert it to another format, say CYME. The convertion process will always be structured in the following way: Instanciate a store object which will store all the objects and attributes of your model from ditto.store import Store m=Store() Instanciate a reader object with the required arguments. These arguments may vary depending on the format. For example, the OpenDSS reader expects a path for the master.dss file as well as a path for the buscoord.dss file. from ditto.readers.opendss.read import reader opendss_reader=reader(master_file='/Users/johny_cash/IEEE_13_node/master.dss, buscoordinates_file='/Users/johny_cash/IEEE_13_node/buscoords.dss') Call the parse method of the reader with the store object as argument. opendss_reader.parse(m) Instanciate a writer object with the required arguments (output folder path\u2026). from ditto.writers.cyme.write import writer cyme_writer=writer(output_path='./', log_path='./') Call the write method of the writer with the store object as argument. cyme_writer.write(m) How is the code structured? Here is a simplified view of the code structure (only the key components are displayed): DiTTo \u2502 README.md \u2502 docs | tests \u2502 \u2514\u2500\u2500\u2500ditto \u2502 store.py \u2502 \u2514\u2500\u2500\u2500core | \u2502 base.py | \u2502 _factory.py | \u2502 exceptions.py | \u2514\u2500\u2500\u2500readers | \u2514\u2500\u2500\u2500cyme | | | read.py | \u2514\u2500\u2500\u2500opendss | | read.py | \u2514\u2500\u2500\u2500writers \u2514\u2500\u2500\u2500cyme | | write.py \u2514\u2500\u2500\u2500opendss | write.py Most of the code is located in the ditto directory. The core structure responsible for storing the objects is implemented in the core folder. Readers are implemented in readers and writers in writers. These two folders then contain the different format in different subfolders. Example 1: The OpenDSS reader is located in: DiTTo/ditto/readers/opendss/read.py And can be imported with: from ditto.readers.opendss.read import Reader Example 2: The CYME writer is located in: DiTTo/ditto/writers/cyme/write.py And can be imported with: from ditto.writers.cyme.write import Writer","title":"Usage"},{"location":"developer-guide/","text":"Developer Guide .. toctree:: :maxdepth: 1 install style docs","title":"Index"},{"location":"developer-guide/#developer-guide","text":".. toctree:: :maxdepth: 1 install style docs","title":"Developer Guide"},{"location":"developer-guide/docs/","text":"Generating Documentation The documentation requires Pandoc to convert from Markdown to RST. You will need the following Python packages. pip install sphinx pip install ghp-import pip install sphinx_rtd_theme pip install nbsphinx pip install sphinxcontrib-pandoc-markdown If you don't have Pandoc, you can install it using conda . conda install pandoc If you are unable to install pandoc , you may be able to generate some of the documentation if you install the following. pip install recommonmark","title":"Docs"},{"location":"developer-guide/docs/#generating-documentation","text":"The documentation requires Pandoc to convert from Markdown to RST. You will need the following Python packages. pip install sphinx pip install ghp-import pip install sphinx_rtd_theme pip install nbsphinx pip install sphinxcontrib-pandoc-markdown If you don't have Pandoc, you can install it using conda . conda install pandoc If you are unable to install pandoc , you may be able to generate some of the documentation if you install the following. pip install recommonmark","title":"Generating Documentation"},{"location":"developer-guide/install/","text":"Installation To develop DiTTo , you will need to follow the development instructions: git clone https://github.com/NREL/ditto pip install -e \".[dev]\" In addition to all the dependencies, this also installs the requirements for running tests. Also, this installs auto code formatters, checks for trailing whitespace, checks for valid AST and checks for merge conflict markers. The pre-commit hooks will not let you commit code that fails these checks. Your code will automatically be formatted when you attempt to make a commit. These auto formatted changes need to be explicitly added to the staging area in order for the commit to be created. If you don't want to run the pre-commit hooks, you can make a commit using the --no-verify flag.","title":"Install"},{"location":"developer-guide/install/#installation","text":"To develop DiTTo , you will need to follow the development instructions: git clone https://github.com/NREL/ditto pip install -e \".[dev]\" In addition to all the dependencies, this also installs the requirements for running tests. Also, this installs auto code formatters, checks for trailing whitespace, checks for valid AST and checks for merge conflict markers. The pre-commit hooks will not let you commit code that fails these checks. Your code will automatically be formatted when you attempt to make a commit. These auto formatted changes need to be explicitly added to the staging area in order for the commit to be created. If you don't want to run the pre-commit hooks, you can make a commit using the --no-verify flag.","title":"Installation"},{"location":"developer-guide/style/","text":"Style Guide The goal of the style guide is to describe in detail naming conventions for developing DiTTo. Naming Conventions 1) All functions and methods should be lower case with use of underscores for clarity def parse_data(): pass 2) All classes should be PascalCase class GridLABDReader(AbstractReader): pass","title":"Style"},{"location":"developer-guide/style/#style-guide","text":"The goal of the style guide is to describe in detail naming conventions for developing DiTTo.","title":"Style Guide"},{"location":"developer-guide/style/#naming-conventions","text":"1) All functions and methods should be lower case with use of underscores for clarity def parse_data(): pass 2) All classes should be PascalCase class GridLABDReader(AbstractReader): pass","title":"Naming Conventions"}]}